import type { BuiltInPlatform } from '@uni-helper/uni-env'
import type { CommentToken } from 'comment-json'

import type { PagesJson } from '../interface'
import type { ResolvedPluginOptions } from '../types/options'
import type { FileManager } from './file-manager'
import type { PagesConfigFile } from './pages-config-file'

import fs from 'node:fs'

import { platform as currentPlatform } from '@uni-helper/uni-env'
import { parse as cjParse } from 'comment-json'
import path from 'pathe'

import { logger } from '../utils/debug'
import { checkFile, writeFileWithLock } from '../utils/file'
import { deepAssign } from '../utils/object'
import { getPageType, getTabbarIndex } from './page-file'
import { PlatformMerger } from './platform-merger'

interface StaticJsonFileInfo {
  platforms: Set<BuiltInPlatform>;
  indent: string;
  eof: string;
}

/**
 * Pages.json 文件的操作
 * 负责 pages.json 文件的检测、读取和写入
 */
export class PagesJsonFile {
  private cachedInfo?: StaticJsonFileInfo
  private lastJson: string = ''

  constructor(
    private readonly options: ResolvedPluginOptions,
    private readonly pagesConfig: PagesConfigFile,
    private readonly fileManager: FileManager,
    private readonly platformMerger = new PlatformMerger(),

  ) {}

  /**
   * 获取文件路径
   */
  getPath(): string {
    return this.options.pagesJsonFilePath
  }

  /**
   * 写入内容到文件
   */
  async write(content: string): Promise<void> {
    await writeFileWithLock(this.getPath(), content)
  }

  /**
   * 异步检测静态 pages.json 文件，如不存在或权限不正确，尝试重建
   */
  async check(): Promise<boolean> {
    try {
      const stat = await fs.promises.stat(this.getPath())
      if (!stat.isFile()) {
        await fs.promises.unlink(this.getPath())
        throw new Error('Not a file')
      }

      try {
        await fs.promises.access(this.getPath(), fs.constants.R_OK | fs.constants.W_OK)
      }
      catch {
        try {
          await fs.promises.unlink(this.getPath())
        }
        catch {
          return false
        }
        throw new Error('Permission error')
      }

      return true
    }
    catch {
      try {
        await fs.promises.mkdir(path.dirname(this.getPath()), { recursive: true })
        const defaultContent = JSON.stringify({ pages: [{ path: '' }] }, null, 4)
        const mode = (fs.constants.R_OK | fs.constants.W_OK) << 6
          | (fs.constants.R_OK | fs.constants.W_OK) << 3
          | (fs.constants.R_OK | fs.constants.W_OK)
        await fs.promises.writeFile(this.getPath(), defaultContent, { encoding: 'utf-8', mode })
        return true
      }
      catch {
        return false
      }
    }
  }

  /**
   * 同步检测静态 pages.json 文件，如不存在或权限不正确，尝试重建
   */
  checkSync(): boolean {
    try {
      const stat = fs.statSync(this.getPath())
      if (!stat.isFile()) {
        fs.unlinkSync(this.getPath())
        throw new Error('Not a file')
      }

      try {
        fs.accessSync(this.getPath(), fs.constants.R_OK | fs.constants.W_OK)
      }
      catch {
        try {
          fs.unlinkSync(this.getPath())
        }
        catch {
          return false
        }
        throw new Error('Permission error')
      }

      return true
    }
    catch {
      try {
        fs.mkdirSync(path.dirname(this.getPath()), { recursive: true })
        const defaultContent = JSON.stringify({ pages: [{ path: '' }] }, null, 4)
        const mode = (fs.constants.R_OK | fs.constants.W_OK) << 6
          | (fs.constants.R_OK | fs.constants.W_OK) << 3
          | (fs.constants.R_OK | fs.constants.W_OK)
        fs.writeFileSync(this.getPath(), defaultContent, { encoding: 'utf-8', mode })
        return true
      }
      catch {
        return false
      }
    }
  }

  /**
   * 检测静态 pages.json 文件信息（使用的platform、换行符、末端换行）
   */
  async detectInfo(forceUpdate = false): Promise<StaticJsonFileInfo> {
    if (!forceUpdate && this.cachedInfo) {
      return this.cachedInfo
    }

    const res: StaticJsonFileInfo = {
      platforms: new Set<BuiltInPlatform>([currentPlatform]),
      indent: ' '.repeat(4),
      eof: '\n',
    }

    const content = await fs.promises.readFile(this.getPath(), { encoding: 'utf-8' }).catch(() => '')
    if (!content) {
      this.cachedInfo = res
      return res
    }

    try {
      const json = cjParse(content) as PagesJson
      const comments = json[Symbol.for('before-all') as any] as CommentToken[]

      for (const comment of comments || []) {
        if (comment && comment.value && comment.value.startsWith(' GENERATED BY uni-pages, PLATFORM:')) {
          const parts = comment.value.split(':')
          if (parts.length >= 2) {
            const pfs = (parts[1] || '').split('||')
            for (let pf of pfs) {
              pf = pf.trim()
              if (!pf) {
                continue
              }
              res.platforms.add(pf as BuiltInPlatform)
            }
          }
        }
      }

      res.indent = ' '.repeat(this.detectIndent(content))

      const lastChar = content[content.length - 1]
      if (lastChar === '\n') {
        res.eof = '\n'
      }
      else {
        res.eof = ''
      }

      this.cachedInfo = res
      return res
    }
    catch {
      this.cachedInfo = res
      return res
    }
  }

  shouldUpdate(newJson: string) {
    return this.lastJson !== newJson
  }

  generateDeclaration(jsons: Record<BuiltInPlatform, PagesJson>) {
    const subPagePaths = new Set<string>()
    const tabPaths = new Set<string>()
    const pagePaths = new Set<string>()

    for (const [, pagesJson] of Object.entries(jsons)) {
      for (const sub of (pagesJson.subPackages || [])) {
        for (const page of (sub.pages || [])) {
          if (sub.root && page.path) {
            subPagePaths.add(`"/${path.join(sub.root, page.path)}"`)
          }
        }
      }

      for (const tab of (pagesJson.tabBar?.list || [])) {
        tabPaths.add(`"/${tab.pagePath}"`)
      }

      for (const page of (pagesJson.pages || [])) {
        const path = `"/${page.path}"`
        if (!tabPaths.has(path)) {
          pagePaths.add(path)
        }
      }
    }

    const allPagePaths = new Set([...pagePaths, ...subPagePaths])

    const code = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by uni-pages

interface NavigateToOptions {
  url: ${[...allPagePaths].join(' |\n       ')};
}
interface RedirectToOptions extends NavigateToOptions {}

interface SwitchTabOptions {
  ${tabPaths.size ? `url: ${[...tabPaths].join(' |\n       ')};` : ''}
}

type ReLaunchOptions = NavigateToOptions | SwitchTabOptions;

declare interface Uni {
  navigateTo(options: UniNamespace.NavigateToOptions & NavigateToOptions): void;
  redirectTo(options: UniNamespace.RedirectToOptions & RedirectToOptions): void;
  switchTab(options: UniNamespace.SwitchTabOptions & SwitchTabOptions): void;
  reLaunch(options: UniNamespace.ReLaunchOptions & ReLaunchOptions): void;
}
`
    return code
  }

  async writeDeclaration(jsons: Record<BuiltInPlatform, PagesJson>, filepath: string) {
    const ok = await checkFile({ path: filepath, newContent: '', modeFlag: fs.constants.W_OK | fs.constants.R_OK })
    if (!ok) {
      return
    }

    const originalContent = await fs.promises.readFile(filepath, 'utf-8')

    const code = this.generateDeclaration(jsons)
    if (!code) {
      return
    }

    if (code !== originalContent) {
      await fs.promises.writeFile(filepath, code)
    }
  }

  /**
   * 根据 platform 生成完整的 pages.json
   */
  async generate(platform = currentPlatform): Promise<PagesJson> {
    const pagesConfig = await this.pagesConfig.getByPlatform(platform) || {}

    // 合并 pages
    const mainPackageMetaList = await this.fileManager.getMainPackageMetaList(platform)
    if (mainPackageMetaList.length > 0) {
      pagesConfig.pages ??= []

      for (const pageMeta of mainPackageMetaList) {
        const idx = pagesConfig.pages.findIndex(p => p.path === pageMeta.path)
        if (idx !== -1) {
          deepAssign(pagesConfig.pages[idx], pageMeta)
        }
        else {
          pagesConfig.pages.push(pageMeta)
        }
      }
    }

    // 合并 subPackages
    const subPackagesMetaList = await this.fileManager.getSubPackagesMetaList(platform)
    if (subPackagesMetaList.length > 0) {
      pagesConfig.subPackages ??= []

      for (const subPackageMetaList of subPackagesMetaList) {
        const idx = pagesConfig.subPackages.findIndex(p => p.root === subPackageMetaList.root)

        if (idx !== -1) {
          pagesConfig.subPackages[idx].pages ??= []

          for (const pageMeta of (subPackageMetaList.pages || [])) {
            const pageMetaIdx = pagesConfig.subPackages[idx].pages.findIndex(p => p.path === pageMeta.path)
            if (pageMetaIdx !== -1) {
              deepAssign(pagesConfig.subPackages[idx].pages[pageMetaIdx], pageMeta)
            }
            else {
              pagesConfig.subPackages[idx].pages.push(pageMeta)
            }
          }
        }
        else {
          pagesConfig.subPackages.push(subPackageMetaList)
        }
      }
    }

    // 合并 tabbar
    const tabbarMetaList = await this.fileManager.getTabbarMetaList(platform)
    if (tabbarMetaList.length > 0) {
      pagesConfig.tabBar ??= {}
      pagesConfig.tabBar.list ??= []

      for (const tabbarMeta of tabbarMetaList) {
        const idx = pagesConfig.tabBar.list.findIndex(item => item.pagePath === tabbarMeta.pagePath)
        if (idx !== -1) {
          deepAssign(pagesConfig.tabBar.list[idx], tabbarMeta)
        }
        else {
          pagesConfig.tabBar.list.push(tabbarMeta)
        }
      }
    }

    this.sortBy(pagesConfig)

    return pagesConfig
  }

  /**
   * 对 pagesJson 进行排序
   */
  sortBy(pagesJson: PagesJson): void {
    // pages 排序： home 页面优先，其他页面按顺序排列
    if (pagesJson.pages) {
      pagesJson.pages.sort((a, b) => {
        if (getPageType(a) === 'home') {
          if (getPageType(b) === 'home') {
            return 0
          }
          else {
            return -1
          }
        }
        else if (getPageType(b) === 'home') {
          return 1
        }
        else {
          return 0
        }
      })
    }

    // tabbar 排序： 按 index 升序排列
    if (pagesJson.tabBar && pagesJson.tabBar.list) {
      pagesJson.tabBar.list.sort((a, b) => getTabbarIndex(a) - getTabbarIndex(b))
    }
  }

  async set() {
    // 获取原本pages.json的文件格式
    const { platforms, indent, eof } = await this.detectInfo(true)

    // 取出对应平台的pages.json
    const jsonMap = {} as Record<BuiltInPlatform, PagesJson>
    for (const platform of platforms) {
      jsonMap[platform] = await this.generate(platform)
    }

    const pagesJson = this.platformMerger.merge(jsonMap, indent, eof)

    if (!this.shouldUpdate(pagesJson)) {
      logger.info('pages.json 内容无改动，跳过写入')
      return
    }

    this.lastJson = pagesJson

    await this.write(pagesJson)

    if (this.options.dts) {
      await this.writeDeclaration(jsonMap, this.options.dts)
    }
  }

  /**
   * 检测缩进
   */
  private detectIndent(code: string): number {
    const lines = code.split(/\r?\n/)
    const indentSizes: number[] = []

    for (const line of lines) {
      if (line.trim().length === 0) {
        continue
      }

      const match = line.match(/^(\s*)/)
      const spaces = match ? match[1].length : 0

      if (spaces > 0) {
        indentSizes.push(spaces)
      }
    }

    if (indentSizes.length === 0) {
      return 2
    }

    const uniqueIndents = [...new Set(indentSizes)].sort((a, b) => a - b)

    if (uniqueIndents.length === 1) {
      return uniqueIndents[0]
    }

    const gcd = (a: number, b: number): number => b === 0 ? a : gcd(b, a % b)
    let baseIndent = uniqueIndents[0]

    for (let i = 1; i < uniqueIndents.length; i++) {
      baseIndent = gcd(baseIndent, uniqueIndents[i])
      if (baseIndent === 1) {
        break
      }
    }

    if (baseIndent >= 2 && baseIndent <= 8) {
      return baseIndent
    }

    return uniqueIndents[0]
  }
}
