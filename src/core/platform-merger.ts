import type { BuiltInPlatform } from '@uni-helper/uni-env'
import type { CommentToken } from 'comment-json'

import type { PagesJson } from '../interface'

import { stringify as commentStringify } from 'comment-json'

const PF_ARR_ITEM_KEY = Symbol.for('platform-array-item')

/**
 * 平台合并服务
 * 负责合并不同平台的 pages.json 配置
 */
export class PlatformMerger {
  /**
   * 将多个平台的 pages.json 合并成一个静态 pages.json
   */
  merge(
    jsons: Record<BuiltInPlatform, PagesJson>,
    indent = ' '.repeat(4),
    eof = '\n',
  ): string {
    const [p1 = 'app-plus' as BuiltInPlatform, ...p2s] = Object.keys(jsons).sort() as BuiltInPlatform[]

    const pagesJson = jsons[p1] || {}

    for (const p2 of p2s) {
      const j2 = jsons[p2]

      // 合并不同平台的 pages
      if (j2.pages) {
        pagesJson.pages = pagesJson.pages || []
        this.mergePlatformArray(p1, pagesJson.pages, p2, j2.pages, v => v.path || '')
      }

      // 合并不同平台的 subPackages
      if (j2.subPackages) {
        pagesJson.subPackages = pagesJson.subPackages || []
        for (const j2Sub of j2.subPackages) {
          const idx = pagesJson.subPackages.findIndex(s => s.root === j2Sub.root)
          if (idx > -1) {
            this.mergePlatformObject(p1, pagesJson.subPackages[idx], p2, j2Sub, ['pages'])
            if (j2Sub.pages && j2Sub.pages.length > 0) {
              pagesJson.subPackages[idx].pages = pagesJson.subPackages[idx].pages || []
              this.mergePlatformArray(p1, pagesJson.subPackages[idx].pages, p2, j2Sub.pages, v => v.path || '')
            }
          }
          else {
            pagesJson.subPackages.push(j2Sub)
          }
        }
      }

      // 合并不同平台的 tabBar
      if (j2.tabBar) {
        pagesJson.tabBar = pagesJson.tabBar || {}
        this.mergePlatformObject(p1, pagesJson.tabBar, p2, j2.tabBar, ['list'])
        if (j2.tabBar.list && j2.tabBar.list.length > 0) {
          pagesJson.tabBar.list = pagesJson.tabBar.list || []
          this.mergePlatformArray(p1, pagesJson.tabBar.list, p2, j2.tabBar.list, v => v.pagePath || '')
        }
      }

      // 合并除 pages、subPackages、tabBar 外的其他属性
      this.mergePlatformObject(p1, pagesJson, p2, j2, ['pages', 'subPackages', 'tabBar'])
    }

    let rawJson = commentStringify(pagesJson, null, indent)

    const comment = `// GENERATED BY uni-pages, PLATFORM: ${[p1, ...p2s].join(' || ')}
//
// 警告：此文件为自动生成，请勿手动修改，否则更改将丢失。
// WARNING: This file is automatically generated. DO NOT EDIT, as your changes will be overwritten.
//
// Repository: https://github.com/skiyee/uni-pages
`
    rawJson = comment + rawJson + eof

    // 清理 key 后缀
    rawJson = rawJson.replace(/"([^"]+)#ifdef_.*?"/g, '"$1"')

    // 修复 #ifdef 行注释位置。（comment-json 将此行注释放在上一个行的末尾，而不是同等缩进的新行）
    // eslint-disable-next-line regexp/no-super-linear-backtracking
    rawJson = rawJson.replace(/\n(\s*.+)\s*(\/\/ #ifdef .*)\n(\s*)/g, '\n$1\n$3$2\n$3')

    // 修复 #endif 行注释位置。（comment-json 将此行注释行末尾，而不是同等缩进的新行）
    // eslint-disable-next-line regexp/no-super-linear-backtracking
    rawJson = rawJson.replace(/\n((\s*).*?)\s*\/\/ #endif/g, '\n$1\n$2// #endif')
    // 清除多余的换行
    rawJson = rawJson.replace(/\n\s*\n/g, '\n')

    return rawJson
  }

  /**
   * 合并两个不同平台的数组
   */
  private mergePlatformArray<T extends object>(
    pf1: BuiltInPlatform,
    v1: T[],
    pf2: BuiltInPlatform,
    v2: T[],
    getKey: (v: T) => string,
  ): void {
    for (const v2item of v2) {
      const v2key = getKey(v2item)
      if (!v2key) {
        continue
      }

      const v1idx = v1.findIndex((v) => {
        const vKey = getKey(v)
        if (!vKey || vKey !== v2key) {
          return false
        }
        const pf = (v as any)[PF_ARR_ITEM_KEY] as BuiltInPlatform | undefined
        return pf === undefined || pf === pf2
      })

      if (v1idx > -1) {
        this.mergePlatformObject(pf1, v1[v1idx], pf2, v2item)
        continue
      }

      const idx = v1.length;
      (v2item as any)[PF_ARR_ITEM_KEY] = pf2
      v1.push(v2item)
      this.wrapIfdef(v1, idx, pf2)
    }
  }

  /**
   * 合并两个不同平台的对象
   */
  private mergePlatformObject<T extends object>(
    pf1: BuiltInPlatform,
    v1: T,
    pf2: BuiltInPlatform,
    v2: T,
    ignoreKeys: string[] = [],
  ): void {
    const v1keys = new Set(Object.keys(v1))
    const ignores = new Set(ignoreKeys)

    for (const key in v2) {
      if (ignores.has(key)) {
        continue
      }

      const v1Child = v1[key] ?? undefined
      const v2Child = v2[key]

      v1keys.delete(key)

      const p1pk = `${key}#ifdef_${pf1}`
      const p2pk = `${key}#ifdef_${pf2}`

      if (v1Child === undefined) {
        (v1 as any)[p2pk] = v2Child
        this.wrapIfdef(v1, p2pk, pf2)
        continue
      }

      if (v1Child === v2Child) {
        continue
      }

      if (Array.isArray(v2Child)) {
        const c1 = JSON.stringify(v1Child)
        const c2 = JSON.stringify(v2Child)
        if (c1 === c2) {
          continue
        }
      }
      else if (typeof v2Child === 'object' && v2Child !== null) {
        this.mergePlatformObject(pf1, v1Child!, pf2, v2Child)
        continue
      }

      delete v1[key];
      (v1 as any)[p1pk] = v1Child
      this.wrapIfdef(v1, p1pk, pf1);
      (v1 as any)[p2pk] = v2Child
      this.wrapIfdef(v1, p2pk, pf2)
    }

    for (const key of v1keys) {
      if (ignores.has(key)) {
        continue
      }

      if (key.includes('#ifdef')) {
        continue
      }

      const v1Child = (v1 as any)[key]
      if (v1Child === undefined) {
        continue
      }

      const p1pk = `${key}#ifdef_${pf1}`
      delete (v1 as any)[key];
      (v1 as any)[p1pk] = v1Child
      this.wrapIfdef(v1, p1pk, pf1)
    }
  }

  /**
   * 为对象属性添加条件编译注释
   */
  private wrapIfdef(obj: any, key: string | number, platform: string): void {
    const upperPlatform = platform.toUpperCase()

    obj[Symbol.for(`before:${key}`)] = [{
      type: 'LineComment',
      value: ` #ifdef ${upperPlatform}`,
      inline: true,
      loc: {
        start: { line: 0, column: 0 },
        end: { line: 0, column: 0 },
      },
    }] as CommentToken[]

    obj[Symbol.for(`after:${key}`)] = [{
      type: 'LineComment',
      value: ` #endif`,
      inline: true,
      loc: {
        start: { line: 0, column: 0 },
        end: { line: 0, column: 0 },
      },
    }] as CommentToken[]
  }
}
